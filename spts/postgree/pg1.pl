#В DBI выполнение запроса SELECT может осуществляться в два этапа. 
#На первом этапе выполняется функция prepare, а на втором этапе функция execute.
#!/usr/bin/perl
use DBI;

$dbh = DBI->connect("dbi:Pg:dbname=template1","postgres","",{PrintError => 0});

if ($DBI::err != 0) {
	print $DBI::errstr . "\n";
	exit($DBI::err);
}

$query = "SELECT * FROM pg_tables";
$sth = $dbh->prepare($query);
$rv = $sth->execute();

if (!defined $rv) {
	print "При выполнении запроса '$query' возникла ошибка: " . $dbh->errstr . "\n";
	exit 1;
}

while (@array = $sth->fetchrow_array()) {
	foreach $i (@array) {
		print "$i\t";
	}
	print "\n";
}

$sth->finish();
$dbh->disconnect();

#Снова пояснения.  Функция prepare говорит сама за себя. Она должна заниматься подготовкой запроса, 
#однако в руководстве DBD::Pg честно написано, что PostgreSQL не поддерживает концепцию подготовки 
#запросов и поэтому данная функция носит чисто косметическую роль - она просто записывает переданный 
#ей запрос в некий буфер, который затем используется функцией execute. 
#Таким образом, мы не анализируем вознкновение ошибок после выполнения prepare, потому что анализировать 
#Нечего: и синтаксическую проверку запроса и возврат ошибок в случае некорретных данных запроса осуществляет 
#только функция execute.Обратите внимение, что здесь мы обрабатываем ошибку по другому. 
#Если запрос SELECT выполнился удачно, то переменная $rv содержит количество записей, которые возвратил запрос, 
#если во время запроса произошла ошибка, то переменная $rv будет неопределена. 
#Сообщение об ошибке теперь берется из переменной $dbh->errstr.
#После того как запрос успешно отработал, мы извлекаем данные, которые он вернул. 
#Делать это можно несколькими способами, но в данный момент я использовал в примере функцию fetchrow_array(), 
#которая выполняется в цикле while. Эта функция возвращает массив, в котором хранятся все поля одной записи. 
#Далее в цикле foreach происходит вывод каждого поля записи в одной строке через табуляцию и после того как все 
#поля закончились следует перенос строки. Цикл while закончится, когда очередной вызов fetchrow_array() вернет 
#пустое значение undef.  
#И наконец вызов $sth->finish говорит, что из запроса, который был ассоциирован с переменной $sth больше не будет 
#Производится чтение данных и таким образом запрос $sth переходит в неактивное состояние. 
#Это нужно, чтобы потом вы могли использовать в программе переменную $sth повторно с новым запросом.


